#read alignments generated by bwa-mem

import pysam as ps
from Bio import SeqIO
from itertools import chain
from shared import *


startPos = -1
endPos = -1

#Read Meta-Information
with open(snakemake.input['metaInf'],'r') as infile:
	data = infile.read().split('\t')
	startPos = int(data[0])
	endPos = int(data[1])


samfile = ps.AlignmentFile(snakemake.input['filteredAlignment'])


#Phase 1: Iterate over all reads and check which overlap region x

counter_regionx_reads = 0
counter_correct_reads = 0
counter_missing_reads = 0
counter_wrong_reads = 0
counter_aligned_reads = 0
counter_correct_pairs = 0
counter_outside_reads = 0
counter_incomplete_pair = 0
counter_augmented_pair = 0
counter_missing_pair = 0

reads_1 = SeqIO.parse(snakemake.input['read1'],'fastq')
reads_2 = SeqIO.parse(snakemake.input['read2'],'fastq')

regionXreadIDs = {} #used to quickly lookup whether an id is in the region
alignmentReadIDs = {}
filteredReads = []
alignmentDict = {}

def isTrueRead(
	startPosRead1,
	startPosRead2,
	suffix,
	readLength,
	startPos,
	endPos
):

	#Phase 1: Determine actual base range of read

	baseStart = -1
	baseEnd = -1
	readOrientation = -1

	if suffix == '/1':
		baseStart = startPosRead1
	elif suffix == '/2':
		baseStart = startPosRead2
	else:
		raise NameError('Invalid suffix: ',suffix)
		
	

	baseEnd = baseStart + readLength


	if baseEnd < startPos or baseStart > endPos:
		return False
	return True

with open(snakemake.output['analysis'],'w') as afile:
	print("Checking Read Files ...")
	for read in chain(reads_1,reads_2):
		readLength = len(read)
		readID = read.id[:-2] #remove mate pair ID
		startPosRead1,startPosRead2 = parseWgsimReadName(readID)
		if isTrueRead(startPosRead1,startPosRead2,read.id[-2:],readLength,startPos,endPos):
			filteredReads.append(read)
			if not readID in regionXreadIDs: #avoid counting mate pairs as duplicates
				regionXreadIDs[readID]=1
				counter_regionx_reads += 1
			else:
				regionXreadIDs[readID]+=1


	print("Checking Alignment File ...")
	for read in samfile.fetch():
		readID = read.query_name
		if not readID in alignmentReadIDs:
			alignmentReadIDs[readID] = 1
		else:
			alignmentReadIDs[readID] += 1
		alignmentDict[readID] = read
	
	for readID in alignmentReadIDs:
		counter_aligned_reads += 1
		if readID in regionXreadIDs and regionXreadIDs[readID] == alignmentReadIDs[readID]:
			counter_correct_pairs += 1 
		else:
			if not readID in regionXreadIDs:
				counter_outside_reads += 1
				refStart = read.reference_start
				refEnd = refStart+read.reference_length
				refName = read.reference_name
				qStart = read.query_alignment_start
				qEnd = read.query_alignment_end
				afile.write('Outside Read: {}-> {}:{} aligned to {}:{} [{}]\n'.format(readID,qStart,qEnd,refStart,refEnd,refName))
				afile.write('Sequence: {} \n'.format(alignmentDict[readID].seq))
			elif regionXreadIDs[readID] == 2 and alignmentReadIDs[readID] == 1:
				counter_incomplete_pair += 1
			elif regionXreadIDs[readID] == 1 and alignmentReadIDs[readID] == 2:
				counter_augmented_pair += 1
			'''
			counter_wrong_reads += 1
			read = alignmentDict[readID]
			refStart = read.reference_start
			refEnd = refStart+read.reference_length
			qStart = read.query_alignment_start
			qEnd = read.query_alignment_end
			afile.write("Wrong Read: {}  -> {}:{} aligned to {}:{}\n".format(readID,qStart,qEnd,refStart,refEnd))
			afile.write("Aligned Portion of the Read : {} \n".format(read.get_reference_sequence()))
			afile.write("Aligned Portion of the Reference : {} \n".format(read.query_alignment_sequence))
			'''

	print("Checking For Missing Reads ...")
	for readID in regionXreadIDs:
		if not readID in alignmentReadIDs:
			if regionXreadIDs[readID] == 2:
				counter_missing_pair += 1
			else:
				counter_missing_reads += 1
			#afile.write('Missing Read: '+readID+'\n')


	matePairCount = sum([1 for x in regionXreadIDs if regionXreadIDs[x] == 2])

	afile.write('Region X Reads (Pairs): '+str(counter_regionx_reads)+'\n')
	afile.write('(Of which both mate pairs are inside the region: '+str(matePairCount)+')\n')
	afile.write('Region X Reads (Singles): '+str(counter_regionx_reads-matePairCount+matePairCount*2)+'\n')
	afile.write('Correct Pairs: '+str(counter_correct_pairs)+'\n' )
	afile.write('Aligned Reads outside of Region X: '+str(counter_outside_reads)+'\n')
	afile.write('Incomplete Pairs: '+str(counter_incomplete_pair)+'\n')
	afile.write('Augmented Pairs: '+str(counter_augmented_pair)+'\n')
	afile.write('Missing Reads (Single): '+str(counter_missing_reads)+'\n')
	afile.write('Missing Pairs: '+str(counter_missing_pair))

with open(snakemake.output['correctAlignments'],'w') as alignmentFile:
	SeqIO.write(filteredReads,alignmentFile,'fastq')
